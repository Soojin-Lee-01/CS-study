1. 선형 자료구조 🐰
- 요소가 일렬로 나열되어 있는 자료 구조

1-1. 연결 리스트
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조
-> 노드 : 데이터와 다른 데이터가 연결 짓는 포인터가 합쳐진 형태 - 노드가 연결되어있는 것을 연결 리스트
  1) 싱글 연결 리스트 (Single Linked List)
    - next 포인터만을 가지면서 현 노드에서 다음 노드만을 가리키는 형태
  2) 이중 연결 리스트 (Double Linked List)
    - next 포인터와 prev 포인터 두개를 가진 형태를 말하며 next 포인터는 다음 노드, 
      prev 포인터는 이전 노드를 가리키는 형태
  3) 원형 이중 연결 리스트 (Circular Linked List)
    - 이중 연결 리스트와 유사, 마지막 노드가 헤드 부분을 가리키면서 순환이 가능하게끔 만듬
- 삽입과 삭제 : node를 그 부분을 끊고 새롭게 연결시키면 끝 -> O(1)
- 탐색 : 데이터를 찾기 위한 기준이 없어서 head에서부터 그 노드를 탐색해야함 -> O(n)

1-2. 배열
- 같은 타입의 변수들을 모아둔 집합의 형태
- 크기가 정해져 있고, 인접한 메모리 위에 있는 데이터를 모아놓은 집합, 중복 허용, 순서 존재
- 탐색 : index 기준으로 탐색 가능 -> O(1)
- index를 이용해 빠르게 검색하고 데이터를 간단히 쌓음
  1) 랜덤 접근 (Random Access)
    - 순차적 접근이 아닌 임의의 인덱스에 해당하는 데이터에 접근 가능

------------------------------------------------------------------------------------------------
! 배열 vs 연결 리스트 !
1. 접근 방법
  - 배열은 랜덤 접근 방법을 채택, 연결 리스트는 순차적 접근을 채택
2. 데이터 추가 및 삭제
  - 배열 : 값을 추가하기위해서 그 값을 넣기 전에 한칸씩 뒤로 미루는 과정 필요
  - 연결 리스트 : 노드를 끊고 거기에 이어줌
--------------------------------------------------------------------------------------------------

1-3. 벡터
- 동적으로 요소를 할당할 수 있는 동적 배열
- 배열은 크기가 정해져있지만 벡터를 동적 배열의 형태를 가짐
- 탐색 : O(1) / 삽입과 삭제 : O(n) -> 맨뒤 삽입 : O(1)

1-4. 스택
- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질 (LIFO, Last In First Out)
- ex) 뒤로가기 저장, 웹 브라우저 방문 기록
- top : 데이터가 삽입되고 나가는 부분
- 탐색 : 모두 돌아보면서 데이터를 찾음 -> O(n)
- 삽입과 삭제 : O(1)

1-5. 큐
- 먼저 넣은 데이터가 먼저 나오는 성질 (FIFO, First In First Out)
- ex) 프로세스, 네트워크 접속을 기다리는 행렬, 캐시 등 / 티켓팅 접속 대기 순위
- Back : 큐에서 삽입하는 부분, Front : 큐에서 나가는 부분
- 탐색 : O(n), 삽입과 삭제 : O(1)


참고한 블로그 : https://velog.io/@sean2337/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8C%80%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%84%93%EA%B3%A0-%EC%96%95%EC%9D%80-CS-%EC%A7%80%EC%8B%9D-%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0



