1. 디자인 패턴
- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 
규약 형태로 만들어 놓은 것

1-1. 싱글톤 패턴 (singleton pattern)
- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴 -> 해당 인스턴스를 다른 모듈들이 공유하는 형태
1) 장점
- 인스턴스 생성할 때 드는 비용이 줄어듬
- 사용하기 쉬움
2) 단점
- 의존성이 높아짐
- Test Driven Developer (TTD)를 할 때 걸림돌이 됨
  -> 단위 테스트를 할 때, 테스트가 서로 독립적이어야 하며 어떤 순서로든 실행할 수 있어야 함
  -> but, 하나의 인스턴스를 공유하고 있기 때문에 독립적이기 어려움

<의존성 주입 (디커플링)>
- 싱글톤 패턴의 단점 (의존성)을 조금 느슨하게 만들어 줄 수 있는 것
- 기존 싱글톤 패턴 -> 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 줌
- 의존성 주입 -> 의존성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입
 --> 메인 모듈은 하위 모듈에 대한 의존성이 떨어짐 (디커플링)
1) 장점
- 테스팅하기 쉽고 마이그레이션(소프트웨어를 한 시스템에서 다른 시스템으로 이동하는 것) 하기도 수월
- 애플리케이션 방향이 일관되고 쉽게 추론 가능
- 모듈 간에 관계들이 조금 더 명확
2) 단점
- 복잡성이 늘어날 수 있음 -> 모듈들을 분리하기 때문에 클래스 수가 늘어남
!! 의존성 주입 원칙
- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
- 상위 모듈, 하위 모듈 둘다 추상화에 의존해야하며, 추상화는 세부사항에 의존해서는 안됨

1-2. 팩토리 패턴 (factory pattern)
- 객체를 사용하는 코드에서 객체 생성 부분을 떼내어 추상화한 패턴, 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 
하위 클래스에서 객테 생성에 관한 구체적인 내용을 결정하는 패턴
- 상위 클래스 : 전체적인 부분 / 하위 클래스 : 상세한 부분
- ex) 상위 클래스 : 카페 / 하위 클래스 : 커피 레시피

1-3. 전략 패턴 (strategy pattern)
- 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서
상호 교체가 가능하게 만든 패턴
- ex) 어떤 카드로 구매할지 고를 때, 각각의 카드마다 코드를 만드는 것이 아니라, 그 카드 부분 코드를 캡슐화하여 넣다뺏다 할 수 있게

1-4. 옵저브 패턴 (obsereve pattern)
- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
- ex) 트위터

1-5. 프록시 패턴 (proxy pattern)
- 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
<프록시 서버>
- 서버와 클라이언트 사이에 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
ex) Nginx 
  1) DDOS 공격 방어
    - 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시키는 공격 유형. 이는 앞단에 프록시 서버를 두고, 
      이를 자동으로 차단하게 함
  2) HTTPS 구축
    - 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있음. 하지만 이를 사용하면 별도의 인증서 설치 없이 손쉽게 
      HTTPS를 구축할 수 있음

1-6. 이터레이터 패턴 (iterator pattern)
- 컬렌션의 요소들에 접근하는 디자인 패턴
